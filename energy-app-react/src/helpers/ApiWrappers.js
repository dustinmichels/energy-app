import buildingsDetail from './BuildingsDetail';
import news from './SustainabilityNews';
import events from './SustainabilityEvents';
import buildingIDs from './../assets/data/buildingIDs';

import { JanData, eTable, wTable, sTable } from './../assets/data/JanData.js';

import {
    solarProduction,
    solarMeter,
    turbine1Production,
    turbine1Meter,
    turbine1Wind,
    turbine1WindMeter,
    turbine2Consumption,
    turbine2ConsumptionMeter,
    turbine2Production,
    turbine2Meter,
    turbine2Wind,
    turbine2WindMeter
} from './ProductionMeters.js'

import { getSpecificRandom, combineData } from './General';

const apiRSS2jsonKey = 'eymrq2p6ts5dcyltdxtmwsxp63xwzrkmirfvaezw';

// 1) For a given building, resource and timeframe, return (from API) 
//      a single value (e.g. gal/week in Burton)
// 2) Energy the windmill generated within a specified timeframe
// 3) Energy generated by solar panels within a specified timeframe
// 4) (eventually) Data over time to generate graphs


/* Naming Convention:
 * getTotal: Returns one number which is the total sum
 * getOverTime: Returns a table with the numbers divided up based on a given time scale
 *
 * Order of variables:
 * building, utility, timeStart, timeEnd, timeScale
 */

var scaleFactorSolar = 12;
var scaleFactorWind = 400;
var scaleFactorGeothermal = 9;
var scaleFactorWater = 400;
var scaleFactorElectricity = 150;
var scaleFactorOther = 60;

export function dateToTimestamp(date) {
    year = date.getFullYear();
    month = date.getMonth()+1;
    day = date.getDate();
    hours = date.getHours();

    if (month < 10) {
        month = '0'+month;
    }

    if (day < 10) {
        day = '0'+day;
    }

    if (hours < 10) {
        hours = '0'+hours;
    }

    timestamp = year+'-'+month+'-'+day+'%20'+hours+':00:00';

    return timestamp;
}

export function timestampToDate(timestamp){
    var day = timestamp.substring(8,10);
    var month = timestamp.substring(5,7);
    var year = timestamp.substring(0,4);
    var hours = timestamp.substring(11,13);

    d = new Date(year, month, day, hours, "00", "00", "00");
    return d;
}

export const cleanupData = (data) => {
    //TODO: change to not be hardcoded
    var total = 0;
    var turb1Name = "Main Campus -  Turbine 1: Public Grid Production";
    var turb2Name = "Main Campus -  Turbine 2 (Kracum): Carleton Grid Production";
    var solarName = "James Hall - James Hall Solar PV";

    for (var i=0; i < data.length; i++) {
        if (data[i]["pointname"] == turb1Name || data[i]["pointname"] == turb2Name || data[i]["pointname"] == solarName){
            total += data[i]["pointvalue"]; 
        } 
    }

    return total;
}

export function getBuildingsList() {
    // return list of every building name with data (e.g. "Burton", "Sayles", etc.)
    // /api/buildings/names
// 
    var buildings = ["Burton", "Sayles", "Severance", "Davis", "Musser", "Myers", "Cassat",
                        "Memo", "Nourse", "Evans", "Goodhue", "Watson", "Scoville"];

    return buildings;
}

export function getBuildingsDetail() {
    return buildingsDetail;
}

export function getUtilitiesList() {
    var utilities = ["electricity", "water"];

    return utilities;
}

export function getUnitsList() {
    var units = {"electricity": "kWh", "water": "gal"}

    return units;
}

export function getDayOfWeek(date) {
    var week = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

    return week[date];
}

export function getMonth(date) {
    var month = ["Jan", "Feb", "Mar", "Apr", "May", "June", "July", "Aug", "Sep", "Oct", "Nov", "Dec"];

    return month[date];
}

export function getSustainabilityNews() {
    newsRSS = 'https://apps.carleton.edu/sustainability/feeds/blogs/sustaining_carleton';
    return convertRSStoJSON(newsRSS);
}

export function getSustainabilityNewsBak() {
    return news;
}

export function getSustainabilityEvents() {
    eventsRSS = 'https://apps.carleton.edu/sustainability/feeds/events';
    return convertRSStoJSON(eventsRSS);
}

export function getSustainabilityEventsBak() {
    return events;
}

function convertRSStoJSON(rssFeed) {
    baseURL = 'https://api.rss2json.com/v1/api.json';
    formatURL = `${baseURL}?rss_url=${rssFeed}&api_key=${apiRSS2jsonKey}&count=${3}`;

    return fetch(formatURL);
}

// -------------------- Electricity Generation -------------------------



function getRandomWind() {
    return getSpecificRandom(500000, 1000000, 1, 1);
}

function getRandomSolar() {
    return getSpecificRandom(500, 1000, 1, 1);
}

function getRandomGeothermal() {
    return getSpecificRandom(700, 1500, 1, 1);
}

// timeStart, timeEnd are Date objects. 
// timeScale is the resolution of the data in minutes (e.g. 1 minute vs 15 minute increments)
export function getEnergyGenerationOverTime(timeStart, timeEnd, timeScale) {
    var numberEntries = Math.round(Math.abs(timeEnd - timeStart) / (60000 * timeScale));
    var currentTime = new Date(timeEnd);

    var table = new Array(numberEntries);
    for (var i = numberEntries-1; i >= 0; i--) {
        table[i] = {};
        table[i]["date"] = currentTime.toString();
        table[i]["wind"] = getRandomWind();
        table[i]["solar"] = getRandomSolar();
        table[i]["geothermal"] = getRandomGeothermal();
        table[i]["total"] = table[i]["wind"] + table[i]["solar"] + table[i]["geothermal"];

        currentTime.setMinutes(currentTime.getMinutes() - timeScale);
    }

    return table;
}

export function getWindGenerationOverTime(timeStart, timeEnd, timeScale) {
    var totals = getEnergyGenerationOverTime(timeStart, timeEnd, timeScale);
    var table = [];
    for (var i = 0; i < totals.length; i++) {
        table[i] = {};
        table[i]["date"] = totals[i]["date"];
        table[i]["wind"] = totals[i]["wind"];
    }

    return table;
}

export function getWindGenerationOverTimeGraphFormat(timeStart, timeEnd, timeScale) {
    var totals = getEnergyGenerationOverTime(timeStart, timeEnd, timeScale);
    var table = [];
    for (var i = 0; i < totals.length; i++) {
        table[i] = {};
        table[i]["x"] = totals[i]["date"];
        table[i]["y"] = totals[i]["wind"];
    }

    return table;
}

export function getSolarGenerationOverTime(timeStart, timeEnd, timeScale) {
    var totals = getEnergyGenerationOverTime(timeStart, timeEnd, timeScale);
    var table = [];
    for (var i = 0; i < totals.length; i++) {
        table[i] = {};
        table[i]["date"] = totals[i]["date"];
        table[i]["solar"] = totals[i]["solar"];
    }

    return table;
}

export function getSolarGenerationOverTimeGraphFormat(timeStart, timeEnd, timeScale) {
    var totals = getEnergyGenerationOverTime(timeStart, timeEnd, timeScale);
    var table = [];
    for (var i = 0; i < totals.length; i++) {
        table[i] = {};
        table[i]["x"] = totals[i]["date"];
        table[i]["y"] = totals[i]["solar"];
    }

    return table;
}

export function getGeothermalGenerationOverTime(timeStart, timeEnd, timeScale) {
    var totals = getEnergyGenerationOverTime(timeStart, timeEnd, timeScale);
    var table = [];

    for (var i = 0; i < totals.length; i++) {
        table[i] = {};
        table[i]["date"] = totals[i]["date"];
        table[i]["geothermal"] = totals[i]["geothermal"];
    }

    return table;
}

export function getGeothermalGenerationOverTimeGraphFormat(timeStart, timeEnd, timeScale) {
    var totals = getEnergyGenerationOverTime(timeStart, timeEnd, timeScale);
    var table = [];

    for (var i = 0; i < totals.length; i++) {
        table[i] = {};
        table[i]["x"] = totals[i]["date"];
        table[i]["y"] = totals[i]["geothermal"];
    }

    return table;
}

export function getTotalGenerationOverTime(timeStart, timeEnd, timeScale) {
    var totals = getEnergyGenerationOverTime(timeStart, timeEnd, timeScale);
    var table = [];
    for (var i = 0; i < totals.length; i++) {
        table[i] = {};
        table[i]["date"] = totals[i]["date"];
        table[i]["total"] = totals[i]["total"];
    }

    return table;
}


export function getEnergyGeneration(timeStart, timeEnd) {
    // return value of how much electricity we are generating from wind/solar, etc
    // /api/generation

    // return map with one entry for "wind", one for "solar", and one for "total"
    // calculate number of 15-min chunks b/w 'timeStart' and 'timeEnd'
    var timeframe = Math.abs(timeEnd - timeStart) / (60000 * 15); // 60,000ms per min * 15min

    var table = [];
    table["wind"] = getRandomWind();
    table["solar"] = getRandomSolar();
    table["geothermal"] = getRandomGeothermal();
    table["total"] = table["wind"] + table["solar"] + table["geothermal"];

    return table;
}

export function getTotalWindGeneration(timeStart, timeEnd) {
    return getEnergyGeneration(timeStart, timeEnd)["wind"];
}

export function getTotalWindConsumption(timeStart, timeEnd) {
    return getEnergyGeneration(timeStart, timeEnd)["wind"]*.25;
}

export function getTotalSolarGeneration(timeStart, timeEnd) {
    return getEnergyGeneration(timeStart, timeEnd)["solar"];
}

export function getTotalGeothermalGeneration(timeStart, timeEnd) {
    return getEnergyGeneration(timeStart, timeEnd)["geothermal"];
}

export function getTotalEnergyGeneration(timeStart, timeEnd) {
    return getEnergyGeneration(timeStart, timeEnd)["total"];
}

export function getCurrentWindGeneration() {
    var timeStart = new Date();
    timeStart.setMinutes(timeStart.getMinutes() - 15);
    var timeEnd = new Date();

    return getTotalWindGeneration(timeStart, timeEnd);
}

export function getCurrentWindConsumption() {
    var timeStart = new Date();
    timeStart.setMinutes(timeStart.getMinutes() - 15);
    var timeEnd = new Date();

    return getTotalWindConsumption(timeStart, timeEnd);
}

export function getCurrentWindSpeed() {
    return getSpecificRandom(0.2, 9, 1, 1);
}

export function getCurrentSolarGeneration() {
    var timeStart = new Date();
    timeStart.setMinutes(timeStart.getMinutes() - 15);
    var timeEnd = new Date();

    return getTotalSolarGeneration(timeStart, timeEnd);
}

export function getCurrentGeothermalGeneration() {
    var timeStart = new Date();
    timeStart.setMinutes(timeStart.getMinutes() - 15);
    var timeEnd = new Date();

    return getTotalGeothermalGeneration(timeStart, timeEnd);
}

export function getCurrentEnergyGeneration() {
    var timeStart = new Date();
    timeStart.setMinutes(timeStart.getMinutes() - 15);
    var timeEnd = new Date();

    return getTotalEnergyGeneration(timeStart, timeEnd);
}


export function getCurrentWindGenerationGraphFormat() {
    var windTable = new Array(2);
    windTable[0] = {};
    windTable[1] = {};
    var wind = {};

    windTable[0]["x"] = "One (kWh)";
    windTable[0]["y"] = getCurrentWindGeneration();

    windTable[1]["x"] = "Two (kWh)";
    windTable[1]["y"] = getCurrentWindGeneration();

    wind["data"] = windTable;
    wind["total"] = windTable[0]['y'] + windTable[1]['y'];

    return wind;
}

export function getTotalWindGenerationGraphFormat(timeStart, timeEnd, timeScale, scaleFactor) {
    var windTable = getWindGenerationOverTime(timeStart, timeEnd, timeScale);
    var kracumWindTable = getWindGenerationOverTime(timeStart, timeEnd, timeScale);

    var finalTable = {};
    var dataTable = new Array(windTable.length);
    var currData = 0;
    var rank = windTable.length;

    for (var i = windTable.length-1; i >= 0; i--) {
        dataTable[i] = {};
        dataTable[i]["x"] = windTable[i]["date"];
        dataTable[i]["y"] = (windTable[i]["wind"] + kracumWindTable[i]["wind"]) * scaleFactor / 1000;

        if (i==windTable.length-1) {
            currData = dataTable[i]["y"];
        } else if (dataTable[i]["y"] > currData) {
            rank-=1;
        }
    }

    finalTable["rank"] = rank;
    finalTable["data"] = dataTable;
    return finalTable
}

// added function to get usage I need
export function getCurrentGenerationGraphFormat() {
    var totalSolar = getCurrentSolarGeneration();
    var totalWind = getCurrentWindGeneration();
    var totalGeothermal = getCurrentGeothermalGeneration();
    var data = new Array(3);
    var generation = {};

    data[0] = {'x': 'Solar (kWh)', 'y': totalSolar};
    data[1] = {'x': 'Geothermal (kWh)', 'y': totalGeothermal};
    data[2] = {'x': 'Wind (kWh)', 'y': totalWind};

    generation["data"] = data;
    generation["total"] = data[0]['y'] + data[1]['y'] + data[2]['y'];
    return generation;
}

export function getTotalGenerationGraphFormat(timeStart, timeEnd, timeScale, scaleFactor) {
    var solarTable = getSolarGenerationOverTimeGraphFormat(timeStart, timeEnd, timeScale);
    var windTable = getWindGenerationOverTimeGraphFormat(timeStart, timeEnd, timeScale);
    var geoTable = getGeothermalGenerationOverTimeGraphFormat(timeStart, timeEnd, timeScale);

    var combinedTable = new Array(solarTable.length);
    var finalTable = {};
    var currData = 0;
    var rank = solarTable.length;

    for (var i=solarTable.length-1; i >= 0; i--) {
        combinedTable[i] = {};
        currDate = new Date(solarTable[i]["x"]);

        switch (scaleFactor){
            case 1:
                combinedTable[i]["x"] = getDayOfWeek(currDate.getDay());
                break;
            case 7:
                if (i==0) {
                    combinedTable[i]["x"] = "-3";
                } else if (i==1) {
                    combinedTable[i]["x"] = "-2";
                } else if (i==2) {
                    combinedTable[i]["x"] = "-1";
                } else if (i==3) {
                    combinedTable[i]["x"] = "Current";
                }
                break;
            case 30:
                combinedTable[i]["x"] = (currDate.getMonth() + 1) + "/" + currDate.getYear().toString().substring(1);
                break;
            case 365:
                combinedTable[i]["x"] = currDate.getFullYear().toString();
                break;
            default:
                combinedTable[i]["x"] = solarTable[i]["date"];
                break;
        }

        combinedTable[i]["y"] = (solarTable[i]["y"] + windTable[i]["y"]
                                    + geoTable[i]["y"]) * scaleFactor /1000;

        if (i==solarTable.length-1) {
            currData = combinedTable[i]["y"];
        } else if (combinedTable[i]["y"] <= currData) {
            rank-=1;
        }
    }

    finalTable["data"] = {};
    finalTable["data"]["wind"] = windTable;
    finalTable["data"]["solar"] = solarTable;
    finalTable["data"]["geo"] = geoTable;
    finalTable["rank"] = rank;
    finalTable["total"] = combinedTable;

    return finalTable;
}

// -------------------- Utility Consumption -------------------------

export function getBuildingUtilityConsumptionOverTime(building, utility, timeStart, timeEnd, timeScale) {

    // different utilities have different "typical" amounts
    var scaleFactor = scaleFactorOther;

    if (utility == "water") {
        scaleFactor = scaleFactorWater;
    } else if (utility == "electricity") {
        scaleFactor = scaleFactorElectricity;
    }

    var buildings = getBuildingsList();

    if (buildings.indexOf(building) % 2 == 0) {
        scaleFactor *= 2;
    }

    var numberEntries = Math.round(Math.abs(timeEnd - timeStart) / (60000 * timeScale));
    var currentTime = new Date(timeEnd);

    var table = new Array(numberEntries);
    for (var i = numberEntries-1; i >= 0; i--) {
        table[i] = {};
        table[i]["date"] = currentTime.toString();

        table[i][utility] = Math.random() * scaleFactor * numberEntries;


        currentTime.setMinutes(currentTime.getMinutes() - timeScale);
    }
    return table;
}

export function getBuildingUtilityConsumptionOverTimeGraphFormat(building, utility, timeStart, timeEnd, timeScale) {

    // different utilities have different "typical" amounts
    var scaleFactor = scaleFactorOther;

    if (utility == "water") {
        scaleFactor = scaleFactorWater;
    } else if (utility == "electricity") {
        scaleFactor = scaleFactorElectricity;
    }

    var buildings = getBuildingsList();

    if (buildings.indexOf(building) % 2 == 0) {
        scaleFactor *= 2;
    }

    var numberEntries = Math.round(Math.abs(timeEnd - timeStart) / (60000 * timeScale));
    var currentTime = new Date(timeEnd);

    var table = new Array(numberEntries);
    for (var i = numberEntries-1; i >= 0; i--) {
        table[i] = {};
        table[i]["x"] = currentTime.toString();

        table[i]["y"] = Math.random() * scaleFactor * numberEntries;


        currentTime.setMinutes(currentTime.getMinutes() - timeScale);
    }
    return table;
}

export function getTotalBuildingUtilityConsumption(building, utility, timeStart, timeEnd) {
    /*
        parameter   | object type
        --------------------------
        'building'  | String 
        'utility'   | String (options for now: "electricity", "water")
        'timeStart' | Date
        'timeEnd'   | Date
    */

    // return value of how much of a resource we have consumed at one building over a time frame
    // /api/buildings/usage/{buildingName}/current?utility={resource}

    // Insert real API call here

    /* RETURN DUMMY DATA (below) */

    // different utilities have different "typical" amounts
//    var scaleFactor = scaleFactorOther;

//    if (utility == "water") {
//        scaleFactor = scaleFactorWater;
//    } else if (utility == "electricity") {
//        scaleFactor = scaleFactorElectricity;
//    }

    // calculate number of 15-min chunks b/w 'timeStart' and 'timeEnd'
    var timeframe = Math.abs(timeEnd - timeStart) / (60000 * 15); // 60,000ms per min * 15min

    if (utility === "water") {
        return getRandomWater() * timeframe;
    } else if (utility === "electricity") {
        return getRandomElectric() * timeframe;
    } else if (utility === "gas") {
        return getRandomGas() * timeframe;
    } else if (utility === "heat") {
        return getRandomHeat() * timeframe;
    }

    return getSpecificRandom(1000, 5000, timeframe, 1);
}

export function getCurrentBuildingUtilityConsumption(building, utility) {
    var timeStart = new Date();
    timeStart.setMinutes(timeStart.getMinutes() - 15);
    var timeEnd = new Date();

    return getTotalBuildingUtilityConsumption(building, utility, timeStart, timeEnd);
}

/*
Returns historical data in form for building card graphs to use: {totals, data > [utility] }
*/
export function getTotalBuildingConsumptionGraphFormat(timeStart, timeEnd, timeScale, scaleFactor, building) {    
    var waterTable = getBuildingUtilityConsumptionOverTimeGraphFormat(building, "water", timeStart, timeEnd, timeScale);
    var electricityTable = getBuildingUtilityConsumptionOverTimeGraphFormat(building, "electricity", timeStart, timeEnd, timeScale);
    var gasTable = getBuildingUtilityConsumptionOverTimeGraphFormat(building, "gas", timeStart, timeEnd, timeScale);
    var heatTable = getBuildingUtilityConsumptionOverTimeGraphFormat(building, "heat", timeStart, timeEnd, timeScale);

    var combinedTable = new Array(waterTable.length);
    var finalTable = {};
    var currData = 0;
    var year = 2018;
    var month = 12;

    for (var i=waterTable.length-1; i >= 0; i--) {
        combinedTable[i] = {};

        switch (scaleFactor){
            case 1:
                combinedTable[i]["x"] = waterTable[i]["x"];
                break;

            case 7:
                if (i==0) {
                    combinedTable[i]["x"] = "-3";
                } else if (i==1) {
                    combinedTable[i]["x"] = "-2";
                } else if (i==2) {
                    combinedTable[i]["x"] = "-1";
                } else if (i==3) {
                    combinedTable[i]["x"] = "Current";
                } else {
                    combinedTable[i]["x"] = "help";
                }
                break;

            case 30:
                // quick fix
                combinedTable[i]["x"] = month + "/" + '18';
                month --;
//                combinedTable[i]["x"] = (currDate.getMonth() + 1) + "/" + currDate.getYear().toString().substring(1);
                break;

            case 365:
                // quick fix
                combinedTable[i]["x"] = year.toString();
                year --;
//                combinedTable[i]["x"] = currDate.getFullYear().toString();
                break;

            default:
                combinedTable[i]["x"] = waterTable[i]["date"];
                break;
        }

        combinedTable[i]["y"] = (waterTable[i]["y"] + electricityTable[i]["y"]
                                    + gasTable[i]["y"] + heatTable[i]["y"]) * scaleFactor /1000;
    }

    finalTable["data"] = {}
    finalTable["data"]["water"] = waterTable;
    finalTable["data"]["electricity"] = electricityTable;
    finalTable["data"]["gas"] = gasTable;
    finalTable["data"]["heat"] = heatTable;
    finalTable["total"] = combinedTable;

    // console.log("Total building consumption", finalTable)

    return finalTable;
}

export function getCurrentBuildingUtilityConsumptionGraphFormat(building1, building2, utility) {
    var utility1 = getCurrentBuildingUtilityConsumption(building1, utility);
    var utility2 = getCurrentBuildingUtilityConsumption(building2, utility)
    var data = new Array(2);
    data[0] = {'x': building1, 'y': utility1};
    data[1] = {'x': building2, 'y': utility2};
    return data;
}

/*
Returns current data in form for building card graphs to use
*/
export function NEWgetCurrentBuildingUtilityConsumptionGraphFormat(building) {
    var totalWater = 0;
    var totalElectricity = 0;
    var totalHeat = 0;
    var totalGas = 0;
    var data = new Array(4);
    var consumption = {};

    var totalWater = getCurrentBuildingUtilityConsumption(building, "water");
    var totalElectricity = getCurrentBuildingUtilityConsumption(building, "electricity");
    var totalHeat = getCurrentBuildingUtilityConsumption(building, "heat");
    var totalGas = getCurrentBuildingUtilityConsumption(building, "gas");

    data[0] = {'x': 'Gas (thm)', 'y': totalGas};
    data[1] = {'x': 'Electricity (kWh)', 'y': totalElectricity};
    data[2] = {'x': 'Heat (kBTU)', 'y': totalHeat};
    data[3] = {'x': 'Water (gal)', 'y': totalWater};

    total = combineData(data);
    consumption["total"] = total;
    consumption["data"] = data;

    return consumption;
}

/*
Returns data in form for overview card graphs to use
*/
export function getCurrentConsumptionGraphFormat() {
    var totalWater = 0;
    var totalElectricity = 0;
    var totalHeat = 0;
    var totalGas = 0;
    var data = new Array(4);
    var consumption = {};
    var buildings = getBuildingsList();

    buildings.forEach(function(building) {
        totalWater += getCurrentBuildingUtilityConsumption(building, "water");
        totalElectricity += getCurrentBuildingUtilityConsumption(building, "electricity");
        totalHeat += getCurrentBuildingUtilityConsumption(building, "heat");
        totalGas += getCurrentBuildingUtilityConsumption(building, "gas");
    });

    data[0] = {'x': 'Gas (thm)', 'y': totalGas};
    data[1] = {'x': 'Electricity (kWh)', 'y': totalElectricity};
    data[2] = {'x': 'Heat (kBTU)', 'y': totalHeat};
    data[3] = {'x': 'Water (gal)', 'y': totalWater};

    total = combineData(data);
    consumption["total"] = total;
    consumption["data"] = data;

    return consumption;
}

export function reformatDate(date){
    // This function reformats the date object into a string that matched the format of a key 
    // in the JSON JanData. Note: at the moment it HARDCODES the month as "1" and year as "18"
    // We'll have to change that if we add more hardcoded data dumps from Lucid.

    newDate = ["1",
               date.getDate(),
               "18"].join('/')+' '+
               // Number(date.getFullYear().toString().substring(2,4))].join('/')+' '+
              [date.getHours(),
               "00"].join(':');

    // console.log(newDate);
    return newDate;
}

export function getCampusUtilityConsumptionOverTime(utility, timeStart, timeEnd, timeScale) {
    var numberEntries = Math.round(Math.abs(timeEnd - timeStart) / (60000 * timeScale));
    var currentTime = new Date(timeEnd);
    var reformattedDate = reformatDate(currentTime);

    var table = new Array(numberEntries);
    for (var i = numberEntries-1; i >= 0; i--) {
        reformattedDate = reformatDate(currentTime);

        table[i] = {};
        table[i]["date"] = reformattedDate.toString();

        var utilityTable = wTable;

        switch (utility) {
            case 'electricity':
                utilityTable = eTable;
                break;
            case 'water':
                utilityTable = wTable;
                break;
            case 'gas':
                utilityTable = sTable;
                break;
            case 'heat':
                utilityTable = sTable;
                break;
        }

        var dataPt = JanData[utilityTable["Burton"]][reformattedDate];

        
        if (typeof dataPt == 'undefined') {
            console.log('UNDEFINED DATA POINT (ApiWrappers.js):' + reformattedDate);

            dataPt = "0";
        }

        table[i][utility] = Number(dataPt);

        currentTime.setMinutes(currentTime.getMinutes() - timeScale);
    }

    return table;
}

/*
Returns data in form for overview card graphs to use
*/
export function getCampusUtilityConsumptionOverTimeGraphFormat(utility, timeStart, timeEnd, timeScale, scaleFactor) {
    var numberEntries = Math.round(Math.abs(timeEnd - timeStart) / (60000 * timeScale));
    var currDate = new Date(timeEnd);
    var reformattedDate = reformatDate(currDate);

    var table = new Array(numberEntries);
    var year = 2018;
    var month = 12;

    for (var i = numberEntries-1; i >= 0; i--) {
        reformattedDate = reformatDate(currDate);

        table[i] = {};

        switch (scaleFactor){
            case 1:
                table[i]["x"]  = getDayOfWeek(currDate.getDay());
                break;

            case 7:
                if (i==0) {
                    table[i]["x"] = "-3";
                } else if (i==1) {
                    table[i]["x"] = "-2";
                } else if (i==2) {
                    table[i]["x"] = "-1";
                } else if (i==3) {
                    table[i]["x"] = "Current";
                } else {
                    table[i]["x"] = "help";
                }
                break;

            case 30:
                // quick fix
                table[i]["x"] = month + "/" + '18';
                month --;
//                combinedTable[i]["x"] = (currDate.getMonth() + 1) + "/" + currDate.getYear().toString().substring(1);
                break;

            case 365:
                // quick fix
                table[i]["x"] = year.toString();
                year --;
//                combinedTable[i]["x"] = currDate.getFullYear().toString();
                break;

            default:
                table[i]["x"] = waterTable[i]["date"];
                break;
        }

        var utilityTable = wTable;

        switch (utility) {
            case 'electricity':
                utilityTable = eTable;
                break;
            case 'water':
                utilityTable = wTable;
                break;
            case 'gas':
                utilityTable = sTable;
                break;
            case 'heat':
                utilityTable = sTable;
                break;
        }

        var dataPt = JanData[utilityTable["Burton"]][reformattedDate];


        if (typeof dataPt == 'undefined') {
            console.log('UNDEFINED DATA POINT (ApiWrappers.js):' + reformattedDate);

            dataPt = "0";
        }

        table[i]["y"] = Number(dataPt);

        currDate.setMinutes(currDate.getMinutes() - timeScale);
    }

    return table;
}

/*
Returns data in form for overview card graphs to use
*/
export function getTotalConsumptionGraphFormat(timeStart, timeEnd, timeScale, scaleFactor) {
    var waterTable = getCampusUtilityConsumptionOverTimeGraphFormat("water", timeStart, timeEnd, timeScale, scaleFactor);
    var electricityTable = getCampusUtilityConsumptionOverTimeGraphFormat("electricity", timeStart, timeEnd, timeScale, scaleFactor);
    var gasTable = getCampusUtilityConsumptionOverTimeGraphFormat("gas", timeStart, timeEnd, timeScale, scaleFactor);
    var heatTable = getCampusUtilityConsumptionOverTimeGraphFormat("heat", timeStart, timeEnd, timeScale, scaleFactor);

    var combinedTable = new Array(waterTable.length);
    var finalTable = {};
    var currData = 0;
    var rank = waterTable.length;
    var year = 2018;
    var month = 12;

    for (var i=waterTable.length-1; i >= 0; i--) {
        combinedTable[i] = {};

        switch (scaleFactor){
            case 1:
                combinedTable[i]["x"] = waterTable[i]["x"];
                break;

            case 7:
                if (i==0) {
                    combinedTable[i]["x"] = "-3";
                } else if (i==1) {
                    combinedTable[i]["x"] = "-2";
                } else if (i==2) {
                    combinedTable[i]["x"] = "-1";
                } else if (i==3) {
                    combinedTable[i]["x"] = "Current";
                } else {
                    combinedTable[i]["x"] = "help";
                }
                break;

            case 30:
                // quick fix
                combinedTable[i]["x"] = month + "/" + '18';
                month --;
//                combinedTable[i]["x"] = (currDate.getMonth() + 1) + "/" + currDate.getYear().toString().substring(1);
                break;

            case 365:
                // quick fix
                combinedTable[i]["x"] = year.toString();
                year --;
//                combinedTable[i]["x"] = currDate.getFullYear().toString();
                break;

            default:
                combinedTable[i]["x"] = waterTable[i]["date"];
                break;
        }

        combinedTable[i]["y"] = (waterTable[i]["y"] + electricityTable[i]["y"]
                                    + gasTable[i]["y"] + heatTable[i]["y"]) * scaleFactor /1000;

        if (i==waterTable.length-1) {
            currData = combinedTable[i]["y"];

        } else if (combinedTable[i]["y"] < currData) {
            rank-=1;
        }
    }

    finalTable["data"] = {}
    finalTable["data"]["water"] = waterTable;
    finalTable["data"]["electricity"] = electricityTable;
    finalTable["data"]["gas"] = gasTable;

    finalTable["rank"] = rank;
    finalTable["total"] = combinedTable;

    return finalTable;
}

export function getTotalCampusUtilityConsumption(utility, timeStart, timeEnd) {
    // return total campus consumption of utility over specified time frame

    // calculate number of 15-min chunks b/w 'timeStart' and 'timeEnd'
    var timeframe = Math.abs(timeEnd - timeStart) / (60000 * 15); // 60,000ms per min * 15min

    switch (utility) {
        case 'electricity':
            return getRandomElectric() * timeframe;
            break;
        case 'water':
            return getRandomWater() * timeframe;
            break;
        case 'gas':
            return getRandomGas() * timeframe;
            break;
        case 'heat':
            return getRandomHeat() * timeframe;
            break;
    }

    return Math.random() * scaleFactor * timeframe; 
}

export function getCurrentCampusUtilityConsumption(utility) {
    var timeStart = new Date();
    timeStart.setMinutes(timeStart.getMinutes() - 15);
    var timeEnd = new Date();

    return getTotalCampusUtilityConsumption(utility, building, timeStart, timeEnd);
}

/*
Returns array of current consumption of every building given a utility in order of
highest to least percentage of total used
*/
export function getEveryBuildingUtilityConsumptionRanked(utility) {
    var buildings = getBuildingsList();

    var total = 0;
    var table = new Array(buildings.length);

    for (var i = 0; i < table.length; i++) {
        table[i] = {};
        table[i]["building"] = buildings[i];
        switch (utility) {
            case 'electricity':
                table[i][utility] = getRandomElectric();
                break;
            case 'water':
                table[i][utility] = getRandomWater();
                break;
            case 'gas':
                table[i][utility] = getRandomGas();
                break;
            case 'heat':
                table[i][utility] = getRandomHeat();
                break;
        }

        total += table[i][utility];
    }

    for (var i = 0; i < table.length; i++) {
        table[i]["percent"] = table[i][utility] / total;
    }

    table = sortByKey(table, "percent");

    return table;
}

/* 
Returns dictionary of current consumption of every building given a utility
*/
export function getEveryBuildingUtilityConsumption(utility) {
    var buildings = getBuildingsList();

    var total = 0;
    var table = {};

    for (var i = 0; i < buildings.length; i++) {
        var building = buildings[i];
        table[building] = {};
        switch (utility) {
            case 'electricity':
                table[building][utility] = getRandomElectric();
                break;
            case 'water':
                table[building][utility] = getRandomWater();
                break;
            case 'gas':
                table[building][utility] = getRandomGas();
                break;
            case 'heat':
                table[building][utility] = getRandomHeat();
                break;
        }

        total += table[building][utility];
    }

    for (var i = 0; i < buildings.length; i++) {
        var building = buildings[i];
        table[building]["percent"] = table[building][utility] / total;
    }

    return table;
}

/*
Returns consumption of every building for all utilites
*/
export function getEveryBuildingEveryUtilityConsumption() {
    var buildings = getBuildingsList();
    var table = {};

    for (var i = 0; i < buildings.length; i++) {
        var building = buildings[i];
        table[building] = {};

        table[building]['electricity'] = getRandomElectric();
        table[building]['water'] = getRandomWater();
        table[building]['gas'] = getRandomGas();
        table[building]['heat'] = getRandomHeat();
    }
    return table;
}

// Helper function to sory the building list (in descending order)
function sortByKey(array, key) {
    return array.sort(function(a, b) {
        var x = a[key]; 
        var y = b[key];
        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
    });
}

function getRandomWater() {
    return getSpecificRandom(100000, 500000, 1, 1);
}

function getRandomGas() {
    return getSpecificRandom(50000, 100000, 1, 1);
}

function getRandomHeat() {
    return getSpecificRandom(50000, 100000, 1, 1);
}

function getRandomElectric() {
    return getSpecificRandom(100000, 500000, 1, 1);
}

/*
Get data in dictionary format of building and turbine energy usage and generation totals
*/
export function getAllHistoricalGraphData() {
    var historicalData = {};
    var currDate = new Date();

    var dayUsageData = getDayGraph(currDate, "usage");
    var dayGenerationData = getDayGraph(currDate, "generation");
    var dayTurbineData = getDayGraph(currDate, "turbine");

    historicalData["dayUsage"] = dayUsageData;
    historicalData["dayGeneration"] = dayGenerationData;
    historicalData["dayTurbine"] = dayTurbineData;

    var weekUsageData = getWeekGraph(currDate, "usage");
    var weekGenerationData = getWeekGraph(currDate, "generation");
    var weekTurbineData = getWeekGraph(currDate, "turbine");

    historicalData["weekUsage"] = weekUsageData;
    historicalData["weekGeneration"] = weekGenerationData;
    historicalData["weekTurbine"] = weekTurbineData;

    var monthUsageData = getMonthGraph(currDate, "usage");
    var monthGenerationData = getMonthGraph(currDate, "generation");
    var monthTurbineData = getMonthGraph(currDate, "turbine");

    historicalData["monthUsage"] = monthUsageData;
    historicalData["monthGeneration"] = monthGenerationData;
    historicalData["monthTurbine"] = monthTurbineData;

    var yearUsageData = getYearGraph(currDate, "usage");
    var yearGenerationData = getYearGraph(currDate, "generation");
    var yearTurbineData = getYearGraph(currDate, "turbine");

    historicalData["yearUsage"] = yearUsageData;
    historicalData["yearGeneration"] = yearGenerationData;
    historicalData["yearTurbine"] = yearGenerationData;

    return historicalData;
}

/*
Get data in dictionary format of historical building energy usage
Format: { [Building] > [time Usage] > {data, total} > [utility]
*/
export function getAllHistoricalBuildingGraphData() {
    var historicalBuildingData = {};
    var currDate = new Date();
    var buildings = getBuildingsList();
    var utilities = ['electricity', 'water', 'gas', 'heat'];

    for (var i = 0; i < buildings.length; i++) {
        var building = buildings[i];
        historicalBuildingData[building] = {};

        dayUsageData = getDayBuildingGraph(currDate, building);
        weekUsageData = getWeekBuildingGraph(currDate, building);
        monthUsageData = getMonthBuildingGraph(currDate, building);
        yearUsageData = getYearBuildingGraph(currDate, building);

        historicalBuildingData[building]["dayUsage"] = dayUsageData;
        historicalBuildingData[building]["weekUsage"] = weekUsageData;
        historicalBuildingData[building]["monthUsage"] = monthUsageData;
        historicalBuildingData[building]["yearUsage"] = yearUsageData;

    }
    return historicalBuildingData;
}

/*
Get data in dictionary format of current building energy usage
Format: { [Building] > {data, total} > [utility]
*/
export function getAllCurrentBuildingGraphData() {
    var currData = {};
    var data = {};
    var totals = {};
    var buildings = getBuildingsList();

    buildings.forEach(function(building) {
        var usage = NEWgetCurrentBuildingUtilityConsumptionGraphFormat(building);
        currData[building] = usage;
    });
    return currData;
}

export function getAllCurrentGraphData() {
    var currData = {};
    var data = {};
    var totals = {};

    var usage = getCurrentConsumptionGraphFormat();
    var generation = getCurrentGenerationGraphFormat();
    var turbineGeneration = getCurrentWindGenerationGraphFormat();
    var turbineConsumption = getCurrentWindConsumption();
    var wind = getCurrentWindSpeed();

    data["usage"] = usage.data;
    data["generation"] = generation.data;
    data["turbine"] = turbineGeneration.data;
    data["windSpeed"] = wind;

    totals["usage"] = usage.total;
    totals["generation"] = generation.total;
    totals["turbine"] = {};
    totals["turbine"]["generation"] = turbineGeneration.total;
    totals["turbine"]["consumption"] = turbineConsumption;

    currData["data"] = data;
    currData["totals"] = totals;
    return currData;
}

function getDayGraph(currDate, type) {
    var comparisonDate = new Date();
    comparisonDate.setDate(currDate.getDate()-7);

    if (type === "usage") {
        return getTotalConsumptionGraphFormat(comparisonDate, currDate, 1440, 1);
    } else if (type === "generation") {
         return getTotalGenerationGraphFormat(comparisonDate, currDate, 1440, 1);
    } else {
        return getTotalWindGenerationGraphFormat(comparisonDate, currDate, 1440, 1);
    }

}

function getWeekGraph(currDate, type) {
    var comparisonDate = new Date();
    comparisonDate.setDate(currDate.getDate()-28);

    if (type === "usage") {
        return getTotalConsumptionGraphFormat(comparisonDate, currDate, 10080, 7);
    } else if (type === "generation") {
        return getTotalGenerationGraphFormat(comparisonDate, currDate, 10080, 7);
    } else {
        return getTotalWindGenerationGraphFormat(comparisonDate, currDate, 10080, 7);
    }

}

function getMonthGraph(currDate, type){
    var comparisonDate = new Date();
    comparisonDate.setMonth(currDate.getMonth()-12);

    if (type === "usage") {
        return getTotalConsumptionGraphFormat(comparisonDate, currDate, 41760, 30);
    } else if (type === "generation") {
        return getTotalGenerationGraphFormat(comparisonDate, currDate, 41760, 30);
    } else {
        return getTotalWindGenerationGraphFormat(comparisonDate, currDate, 41760, 30);
    }
}

function getYearGraph(currDate, type) {
    var comparisonDate = new Date();
    comparisonDate.setYear(currDate.getFullYear()-4);

    if (type === "usage") {
        return getTotalConsumptionGraphFormat(comparisonDate, currDate, 525600, 365);
    } else if (type === "generation") {
        return getTotalGenerationGraphFormat(comparisonDate, currDate, 525600, 365);
    } else {
        return getTotalWindGenerationGraphFormat(comparisonDate, currDate, 525600, 365);
    }
}

/*           TIME GRAPHS FOR BUILDING GRAPH DATA              */


function getDayBuildingGraph(currDate, building) {
    var comparisonDate = new Date();
    comparisonDate.setDate(currDate.getDate()-7);
    // console.log("Day building", getTotalBuildingConsumptionGraphFormat(comparisonDate, currDate, 1440, 1, building))
    return getTotalBuildingConsumptionGraphFormat(comparisonDate, currDate, 1440, 1, building);
}

function getWeekBuildingGraph(currDate, building) {
    var comparisonDate = new Date();
    comparisonDate.setDate(currDate.getDate()-28);
    return getTotalBuildingConsumptionGraphFormat(comparisonDate, currDate, 10080, 7, building);
}

function getMonthBuildingGraph(currDate, building){
    var comparisonDate = new Date();
    comparisonDate.setMonth(currDate.getMonth()-12);
    return getTotalBuildingConsumptionGraphFormat(comparisonDate, currDate, 41760, 30, building);
}

function getYearBuildingGraph(currDate, building) {
    var comparisonDate = new Date();
    comparisonDate.setYear(currDate.getFullYear()-4);
    return getTotalBuildingConsumptionGraphFormat(comparisonDate, currDate, 525600, 365, building);
}

// export function getBuildingIDs() {
//     var buildings = {"Burton":39, "Sayles":10, "Severance":61, "Davis":44, "Musser":57, 
//                     "Myers":58, "Cassat":40, "Memo":50, "Nourse":59, "Evans":45, 
//                     "Goodhue":47, "Watson":64, "Scoville":60};
//     return buildings;
// }

export function getConsumptionDataTableAllBuildings(date) {
    // Return a table of all relevant data for ALL buildings
    // Table will have a row for each building

    // var buildings = getBuildingIDs();
    var buildings = buildingIDs;

    table = {};
    for (var i=0; i<buildings.length; i++){
        table[i] = getConsumptionDataTableForBuilding(buildings[i], date);
    }

    return table;
}

export function getConsumptionDataTableForBuilding(building, date) {
    // Data we need FOR EACH UTILITY TYPE (3 utilities): 
    // • 7 datapoints: value @ this time of day (hour) over the last 7 days
    // • 12 datapoints: value @ this time (hour) on this day of the month (1st - 30th) over the last 12 months
    // • 4 datapoints: value @ this time (hour) on this day of the week (mon/tue/wed)over the last 4 weeks
    // • 5 datapoints: value @ this day of the year (DD/MM) over the past 5 years

    var table = {};
    // Here's a visual reference for the layout of the data "table" (object, really)
    table[building] = {
        electricity:{
            days: [],
            weeks: [],
            months: [],
            years: []
        },
        water:{
            days: [],
            weeks: [],
            months: [],
            years: []},
        heat:{
            days: [],
            weeks: [],
            months: [],
            years: []}
    };

    // var buildingID = getBuildingIDs()[building];
    var buildingID = buildingIDs[building];

    // Historical data dump only went up until the beginning of 2018
    // If we pass in a date beyond then, we'll get no data back from the API
    if (date.getFullYear() > 2017){
        date = new Date("2017", "00", "01", "00", "00", "00", "00");
    }

    // get data for last 7 days (value on this hour yesterday, day before,...)
    for (let daysAgo=0; daysAgo<7; daysAgo++){
        var start = new Date(date);
        var end = new Date(date);

        start.setDate(date.getDate()-daysAgo);
        end.setDate(date.getDate()-daysAgo);
        end.setHours(start.getHours() + 1);

        startStamp = dateToTimestamp(start);
        endStamp = dateToTimestamp(end);
        var url = 'http://energycomps.its.carleton.edu/api/index.php/values/building/'+buildingID+'/'+startStamp+'/'+endStamp;
    
        console.log(url);
        fetch(url).then((response) => response.json()).then((responseJson) => {

            console.log(responseJson.length);

            if (responseJson.length == 0) {
                console.log("NO DATA: " + url);
                // TO DO: fill in the table with NULL or 0 values rather than completely skipping them
            }

            for (let i =0; i < responseJson.length ; i++) {

                obj = responseJson[i];
                // name = obj.name.substring(15,24)
                val = obj.pointvalue.toFixed(2)
                units = obj.units;

                switch (units) {
                    case "kWh":
                        table[building].electricity.days.push(val);
                        console.log(table);
                        break;
                    case "kBTU":
                        table[building].heat.days.push(val);
                        console.log(table);
                        break;
                    case "gal":
                        table[building].water.days.push(val);
                        console.log(table);
                        break;
                }

            }

        })
        .catch((error) => {
            console.error(error);
        });

    }


    // get data for last 12 months (value on this hour of this day last month, month before,...)
    for(let monthsAgo=0; monthsAgo<12; monthsAgo++){
        var start = new Date(date);
        var end = new Date(date);

        start.setMonth(date.getMonth()-monthsAgo);
        end.setMonth(date.getMonth()-monthsAgo);
        end.setHours(start.getHours() + 1);

        startStamp = dateToTimestamp(start);
        endStamp = dateToTimestamp(end);
        var url = 'http://energycomps.its.carleton.edu/api/index.php/values/building/'+buildingID+'/'+startStamp+'/'+endStamp;
    
        console.log(url);
        fetch(url).then((response) => response.json()).then((responseJson) => {

            console.log(responseJson.length);

            if (responseJson.length == 0) {
                console.log("NO DATA: " + url);
                // TO DO: fill in the table with NULL or 0 values rather than completely skipping them
            }

            for (let i =0; i < responseJson.length ; i++) {

                obj = responseJson[i];
                // name = obj.name.substring(15,24)
                val = obj.pointvalue.toFixed(2)
                units = obj.units;

                switch (units) {
                    case "kWh":
                        table[building].electricity.months.push(val);
                        console.log(table);
                        break;
                    case "kBTU":
                        table[building].heat.months.push(val);
                        console.log(table);
                        break;
                    case "gal":
                        table[building].water.months.push(val);
                        console.log(table);
                        break;
                }

            }

        })
        .catch((error) => {
            console.error(error);
        });
    }

    // get data for last 4 weeks (value on this hour of this day last week, week before,...)
    for(let weeksAgo=0; weeksAgo<4; weeksAgo++){
        var start = new Date(date);
        var end = new Date(date);

        start.setDate(date.getDate()-7*weeksAgo);
        end.setDate(date.getDate()-7*weeksAgo);
        end.setHours(start.getHours() + 1);

        startStamp = dateToTimestamp(start);
        endStamp = dateToTimestamp(end);
        var url = 'http://energycomps.its.carleton.edu/api/index.php/values/building/'+buildingID+'/'+startStamp+'/'+endStamp;
    
        console.log(url);
        fetch(url).then((response) => response.json()).then((responseJson) => {

            console.log(responseJson.length);

            if (responseJson.length == 0) {
                console.log("NO DATA: " + url);
                // TO DO: fill in the table with NULL or 0 values rather than completely skipping them
            }

            for (let i =0; i < responseJson.length ; i++) {

                obj = responseJson[i];
                // name = obj.name.substring(15,24)
                val = obj.pointvalue.toFixed(2)
                units = obj.units;

                switch (units) {
                    case "kWh":
                        table[building].electricity.weeks.push(val);
                        console.log(table);
                        break;
                    case "kBTU":
                        table[building].heat.weeks.push(val);
                        console.log(table);
                        break;
                    case "gal":
                        table[building].water.weeks.push(val);
                        console.log(table);
                        break;
                }

            }

        })
        .catch((error) => {
            console.error(error);
        });
    }


    // get data for last 5 years (value on this hour of this day last year, year before,...)
    for(let yearsAgo=0; yearsAgo<5; yearsAgo++){
        var start = new Date(date);
        var end = new Date(date);

        start.setFullYear(date.getFullYear()-yearsAgo);
        end.setFullYear(date.getFullYear()-yearsAgo);
        end.setHours(start.getHours() + 1);

        startStamp = dateToTimestamp(start);
        endStamp = dateToTimestamp(end);
        var url = 'http://energycomps.its.carleton.edu/api/index.php/values/building/'+buildingID+'/'+startStamp+'/'+endStamp;
    
        console.log(url);
        fetch(url).then((response) => response.json()).then((responseJson) => {

            console.log(responseJson.length);

            if (responseJson.length == 0) {
                console.log("NO DATA: " + url);
                // TO DO: fill in the table with NULL or 0 values rather than completely skipping them 
            }

            for (let i =0; i < responseJson.length ; i++) {

                obj = responseJson[i];
                // name = obj.name.substring(15,24)
                val = obj.pointvalue.toFixed(2)
                units = obj.units;

                switch (units) {
                    case "kWh":
                        table[building].electricity.years.push(val);
                        console.log(table);
                        break;
                    case "kBTU":
                        table[building].heat.years.push(val);
                        console.log(table);
                        break;
                    case "gal":
                        table[building].water.years.push(val);
                        console.log(table);
                        break;
                }

            }

        })
        .catch((error) => {
            console.error(error);
        });
    }

}





























export function getFormattedData(buildingName, date, daysAgo){
    var end = new Date(date);
    end.setHours(0); // midnight earlier today
    var start = new Date(end);

    if (date.getFullYear() > 2017) {
        start.setFullYear(2017);
        end.setFullYear(2017);
    }

    var numDaysAgo = daysAgo;
    start.setDate(start.getDate()-numDaysAgo);

    startStamp = dateToTimestamp(start);
    endStamp = dateToTimestamp(end);

    var buildingID = buildingIDs[buildingName];

    var url = 'http://energycomps.its.carleton.edu/api/index.php/values/building/'+buildingID+'/'+startStamp+'/'+endStamp;
    console.log(url);


    fetch(url).then((response) => response.json()).then((responseJson) => {
        var daySums = sumHoursToDays(responseJson);
        var weekSums = sumDaysToWeeks(daySums);
        var monthSums = sumDaysToMonths(daySums);
        var yearSums = sumMonthsToYears(monthSums);

        console.log(daySums);
        console.log(weekSums);
        console.log(monthSums);
        console.log(yearSums);

        var result = { 
            "dayUsage":{ 
                "data" : {"electricity": [], "heat": [], "water": [],},
                "total":[]
            }, 
            "weekUsage":{ 
                "data" : {"electricity": [], "heat": [], "water": [],},
                "total":[]
            }, 
            "monthUsage":{ 
                "data" : {"electricity": [], "heat": [], "water": [],},
                "total":[]
            }, 
            "yearUsage":{ 
                "data" : {"electricity": [], "heat": [], "water": [],},
                "total":[]
            } 
        };
        
        // get an array of the most recent 7 items from daySums
        var daySumsElectric = sortByKey(Object.entries(daySums["electricDictDay"]));
        var daySumsHeat = sortByKey(Object.entries(daySums["heatDictDay"]));
        var daySumsWater = sortByKey(Object.entries(daySums["waterDictDay"]));
        for (let i = 0; i < 7; i++) {
            var itemElectric = daySumsElectric[i];
            var objElectric = {"x":"0","y":0};
            objElectric["x"] = itemElectric[0];
            objElectric["y"] = itemElectric[1];
            result["dayUsage"]["data"]["electricity"].push(objElectric);

            var itemHeat = daySumsHeat[i];
            var objHeat = {"x":"0","y":0};
            objHeat["x"] = itemHeat[0];
            objHeat["y"] = itemHeat[1];
            result["dayUsage"]["data"]["heat"].push(objHeat);

            var itemWater = daySumsWater[i];
            var objWater = {"x":"0","y":0};
            objWater["x"] = itemWater[0];
            objWater["y"] = itemWater[1];
            result["dayUsage"]["data"]["water"].push(objWater);
        }

        // get an array of the most recent 4 items from weekSums
        var weekSumsElectric = sortByKey(Object.entries(weekSums["electricDictWeek"]));
        var weekSumsHeat = sortByKey(Object.entries(weekSums["heatDictWeek"]));
        var weekSumsWater = sortByKey(Object.entries(weekSums["waterDictWeek"]));
        for (let i = 0; i < 4; i++) {
            var itemElectric = weekSumsElectric[i];
            var objElectric = {"x":"0","y":0};
            objElectric["x"] = itemElectric[0];
            objElectric["y"] = itemElectric[1];
            result["weekUsage"]["data"]["electricity"].push(objElectric);

            var itemHeat = weekSumsHeat[i];
            var objHeat = {"x":"0","y":0};
            objHeat["x"] = itemHeat[0];
            objHeat["y"] = itemHeat[1];
            result["weekUsage"]["data"]["heat"].push(objHeat);

            var itemWater = weekSumsWater[i];
            var objWater = {"x":"0","y":0};
            objWater["x"] = itemWater[0];
            objWater["y"] = itemWater[1];
            result["weekUsage"]["data"]["water"].push(objWater);
        }

        // get an array of the most recent 4 items from monthSums
        var monthSumsElectric = sortByKey(Object.entries(monthSums["electricDictMonth"]));
        var monthSumsHeat = sortByKey(Object.entries(monthSums["heatDictMonth"]));
        var monthSumsWater = sortByKey(Object.entries(monthSums["waterDictMonth"]));
        for (let i = 0; i < 4; i++) {
            var itemElectric = monthSumsElectric[i];
            var objElectric = {"x":"0","y":0};
            objElectric["x"] = itemElectric[0];
            objElectric["y"] = itemElectric[1];
            result["monthUsage"]["data"]["electricity"].push(objElectric);

            var itemHeat = monthSumsHeat[i];
            var objHeat = {"x":"0","y":0};
            objHeat["x"] = itemHeat[0];
            objHeat["y"] = itemHeat[1];
            result["monthUsage"]["data"]["heat"].push(objHeat);

            var itemWater = monthSumsWater[i];
            var objWater = {"x":"0","y":0};
            objWater["x"] = itemWater[0];
            objWater["y"] = itemWater[1];
            result["monthUsage"]["data"]["water"].push(objWater);
        }

        // get an array of the most recent 1 item from yearSums
        // data capacity is only ONE year at a time
        var yearSumsElectric = sortByKey(Object.entries(yearSums["electricDictYear"]));
        var yearSumsHeat = sortByKey(Object.entries(yearSums["heatDictYear"]));
        var yearSumsWater = sortByKey(Object.entries(yearSums["waterDictYear"]));
        for (let i = 0; i < 1; i++) {
            var itemElectric = yearSumsElectric[i];
            var objElectric = {"x":"0","y":0};
            objElectric["x"] = itemElectric[0];
            objElectric["y"] = itemElectric[1];
            result["yearUsage"]["data"]["electricity"].push(objElectric);

            var itemHeat = yearSumsHeat[i];
            var objHeat = {"x":"0","y":0};
            objHeat["x"] = itemHeat[0];
            objHeat["y"] = itemHeat[1];
            result["yearUsage"]["data"]["heat"].push(objHeat);

            var itemWater = yearSumsWater[i];
            var objWater = {"x":"0","y":0};
            objWater["x"] = itemWater[0];
            objWater["y"] = itemWater[1];
            result["yearUsage"]["data"]["water"].push(objWater);
        }

        // add extra year data (HARD-CODED for now)
        // TO-DO: don't rely on hard-coded data; make an API query for each year
        
        

        console.log(result);

    })
    .catch((error) => {
        console.error(error);
    });

}

function sumHoursToDays(responseJson){

    electricDictDay = {};
    waterDictDay = {};
    heatDictDay = {};

    var size = responseJson.length-1;

    if (size <= 0) {
        console.log("NO DATA: " + url);
    }

    for (let i = size ; i > -1; i--) {


        var obj = responseJson[i];
        var val = obj.pointvalue;
        var units = obj.units;

        var date = obj.pointtimestamp.substring(0,10);

        switch (units) {
            case "kWh":
                if (date in electricDictDay){
                    electricDictDay[date] = electricDictDay[date] + val;
                } else {
                    electricDictDay[date] = val;
                }
                break;
            case "kBTU":
                if (date in heatDictDay){
                    heatDictDay[date] = heatDictDay[date] + val;
                } else {
                    heatDictDay[date] = val;
                }
                break;
            case "gal":
                if (date in waterDictDay){
                    waterDictDay[date] = waterDictDay[date] + val;
                } else {
                    waterDictDay[date] = val;
                }
                break;
        }
    }

    return { electricDictDay, heatDictDay, waterDictDay };
}

function sumDaysToWeeks(daySums){
    // takes a dictionary of day sums (3 nested dictionaries: 1 for each utility).
    // returns 3 dictionaries (1 for each utility) nested within a larger object.
    // values are sums of usage data over 7 days
    // keys are the timstamps for the START of the summed week

    electricDictDay = daySums["electricDictDay"];
    heatDictDay = daySums["heatDictDay"];
    waterDictDay = daySums["waterDictDay"];

    electricDictWeek = {};
    heatDictWeek = {};
    waterDictWeek = {};

    electricArr = sortByKey(Object.keys(electricDictDay));
    heatArr = sortByKey(Object.keys(heatDictDay));
    waterArr = sortByKey(Object.keys(waterDictDay));

    var weekLabel = electricArr[electricArr.length-1];
    for (let week = 0; week < 4; week++) {
        for (let day = 0; day < 7; day++){
            var idx = week*7+day;
            if (idx >= electricArr.length){
                break;
            }

            if (day == 6){
                weekLabel = electricArr[idx];
            }

            var electricKey = electricArr[idx];
            var val = electricDictDay[electricKey];

            if (weekLabel in electricDictWeek){
                electricDictWeek[weekLabel] = electricDictWeek[weekLabel] + val;
            } else {
                electricDictWeek[weekLabel] = val;
            }

        }
    }

    var weekLabel = heatArr[heatArr.length-1];
    for (let week = 0; week < 4; week++) {
        for (let day = 0; day < 7; day++){
            var idx = week*7+day;
            if (idx >= heatArr.length){
                break;
            }

            if (day == 6){
                weekLabel = heatArr[idx];
            }

            var heatKey = heatArr[idx];
            var val = heatDictDay[heatKey];

            if (weekLabel in heatDictWeek){
                heatDictWeek[weekLabel] = heatDictWeek[weekLabel] + val;
            } else {
                heatDictWeek[weekLabel] = val;
            }

        }
    }

    var weekLabel = waterArr[waterArr.length-1];
    for (let week = 0; week < 4; week++) {
        for (let day = 0; day < 7; day++){
            var idx = week*7+day;
            if (idx >= waterArr.length){
                break;
            }

            if (day == 6){
                weekLabel = waterArr[idx];
            }

            var waterKey = waterArr[idx];
            var val = waterDictDay[waterKey];

            if (weekLabel in waterDictWeek){
                waterDictWeek[weekLabel] = waterDictWeek[weekLabel] + val;
            } else {
                waterDictWeek[weekLabel] = val;
            }

        }
    }

    return {electricDictWeek, heatDictWeek, waterDictWeek};
}

function sumDaysToMonths(daySums){
    // QUICK-FIX: a "month" is the past 30 days
    // TO DO: change it to ACTUALLY sum the last month (not just 30 days)

    electricDictDay = daySums["electricDictDay"];
    heatDictDay = daySums["heatDictDay"];
    waterDictDay = daySums["waterDictDay"];

    electricDictMonth = {};
    heatDictMonth = {};
    waterDictMonth = {};

    electricArr = sortByKey(Object.keys(electricDictDay));
    heatArr = sortByKey(Object.keys(heatDictDay));
    waterArr = sortByKey(Object.keys(waterDictDay));

    var idx = 0;
    var monthNum = electricArr[idx].substring(0,7); 
    var val = 0;

    while (true) {

        if (idx >= electricArr.length){
            // if we have fewer than 4 months of day data, break infinite loop:
            break;
        } else {
            monthNum = electricArr[idx].substring(0,7);
            val = electricDictDay[electricArr[idx]];
        }
        
        // sum vals from days WITHIN this month
        if (monthNum in electricDictMonth){
            electricDictMonth[monthNum] = electricDictMonth[monthNum] + val;
        } else {
            electricDictMonth[monthNum] = val;
        }

        idx++; // next day
    }

    idx = 0;
    monthNum = heatArr[idx].substring(0,7); 

    while (true) {

        if (idx >= heatArr.length){
            // if we have fewer than 4 months of day data, break infinite loop:
            break;
        } else {
            monthNum = heatArr[idx].substring(0,7);
            val = heatDictDay[heatArr[idx]];
        }
        
        // sum vals from days WITHIN this month
        if (monthNum in heatDictMonth){
            heatDictMonth[monthNum] = heatDictMonth[monthNum] + val;
        } else {
            heatDictMonth[monthNum] = val;
        }

        idx++; // next day
    }

    idx = 0;
    monthNum = waterArr[idx].substring(0,7); 

    while (true) {

        if (idx >= waterArr.length){
            // if we have fewer than 4 months of day data, break infinite loop:
            break;
        } else {
            monthNum = waterArr[idx].substring(0,7);
            val = waterDictDay[waterArr[idx]];
        }
        
        // sum vals from days WITHIN this month
        if (monthNum in waterDictMonth){
            waterDictMonth[monthNum] = waterDictMonth[monthNum] + val;
        } else {
            waterDictMonth[monthNum] = val;
        }

        idx++; // next day
    }

    return {electricDictMonth, heatDictMonth, waterDictMonth};
}

function sumMonthsToYears(monthSums){

    electricDictMonth = monthSums["electricDictMonth"];
    heatDictMonth = monthSums["heatDictMonth"];
    waterDictMonth = monthSums["waterDictMonth"];

    electricDictYear = {};
    heatDictYear = {};
    waterDictYear = {};

    electricArr = sortByKey(Object.keys(electricDictMonth));
    heatArr = sortByKey(Object.keys(heatDictMonth));
    waterArr = sortByKey(Object.keys(waterDictMonth));

    var idx = 0;
    var yearNum = electricArr[idx].substring(0,4); 
    var val = 0;

    while (true) {

        if (idx >= electricArr.length){
            // if we have fewer than 4 years of month data, break infinite loop:
            break;
        } else {
            yearNum = electricArr[idx].substring(0,4);
            val = electricDictMonth[electricArr[idx]];
        }
        
        // sum vals from months WITHIN this year
        if (yearNum in electricDictYear){
            electricDictYear[yearNum] = electricDictYear[yearNum] + val;
        } else {
            electricDictYear[yearNum] = val;
        }

        idx++; // next month
    }

    idx = 0;
    yearNum = heatArr[idx].substring(0,4); 

    while (true) {

        if (idx >= heatArr.length){
            // if we have fewer than 4 years of month data, break infinite loop:
            break;
        } else {
            yearNum = heatArr[idx].substring(0,4);
            val = heatDictMonth[heatArr[idx]];
        }
        
        // sum vals from months WITHIN this year
        if (yearNum in heatDictYear){
            heatDictYear[yearNum] = heatDictYear[yearNum] + val;
        } else {
            heatDictYear[yearNum] = val;
        }

        idx++; // next month
    }

    idx = 0;
    yearNum = waterArr[idx].substring(0,4); 

    while (true) {

        if (idx >= waterArr.length){
            // if we have fewer than 4 years of month data, break infinite loop:
            break;
        } else {
            yearNum = waterArr[idx].substring(0,4);
            val = waterDictMonth[waterArr[idx]];
        }
        
        // sum vals from months WITHIN this year
        if (yearNum in waterDictYear){
            waterDictYear[yearNum] = waterDictYear[yearNum] + val;
        } else {
            waterDictYear[yearNum] = val;
        }

        idx++; // next month
    }

    return {electricDictYear, heatDictYear, waterDictYear};
}




